#!/bin/bash

[[ "$debug" == 1 ]] && set -x
[[ "$COLUMNS" == '' ]] && { COLUMNS="$(tput cols)" || Optp= ;}
# echo "cols:$COLUMNS"

#PATH=''

function usage {
while read useline
do echo "$useline"
done <<'DOC'
usage: $0 [-dp] [-h|--help]
-h | show help
-P | dont show current searching path
-d | search files and directories starting with .
-p | pipe output to PAGER
-f | faster search (by using subprocesses)
-r | use regex patterns in input string
-s | max subprocesses per process. only applies with -f
-F | search in files instead of filenames
DOC
exit 0
}

[[ "$@" == *"--help"* ]] && usage
((MaxSubs=4))
while getopts ":dpPhfrs:F" ARG
do
	case "${ARG}" in
		h ) usage;;
		d ) pattern=".[^.]* $pattern";;
		P ) Optp=;;
		p ) Optpager=;;
		f ) Optf='&'; echo "fast mode '$Optf'";Optp= ; export Optf Optp;;
		r ) Optr='regex';;
		s ) MaxSubs="$OPTARG";;
		F ) echo "currently broken..."; exit 1; OptF='&';;
	esac
done
shift $((OPTIND-1))
q="$@"

until [[ "$cnt" -ge $(($COLUMNS-3)) ]]
do whiteline="${whiteline} ";((cnt++))
done
unset cnt
function clline {
	#echo -ne "$whiteline\r"
	printf " %.0s" $(eval "echo {1..$(($COLUMNS-1))}")
	echo -ne "\r"
}

function displayfile {
	clline
	path="$(pwd)"
	file="$path"
	[[ -v Optp ]] || echo -ne "${path:0:$COLUMNS}\r"
}

function error {
    echo ''
    printf "=%.0s" $(eval "echo {1..$COLUMNS}") && echo ''
    echo "error: $1"
	echo "waiting for subprocesses if present"
	wait
	echo "done"
    [[ "$1" == interrupt ]] && exit 0
    exit 1
}
NL="$(echo '')"
if [[ -v Optr ]]
then echo "using regex mode"
function match {
	if [[ "$1" == $2 ]]
	then
        clline
		if [[ -v Optpager ]]
		then plist="$plist\n$(pwd)$file"
		else echo -e "\r\e[30;47mmatch:\e[0m $(pwd)/$1"
		fi
		((found++))
     fi
}
elif [[ -v OptF ]]
then
function match {
	cnt=0
	while read line
	do ((cnt++))
		if [[ "$line" == *"$2"* ]]
		then
			clline
			if [[ -v Optpager ]]
			then plist="$plist\n$(pwd)$file@$cnt"
			else echo -e "\r\e[30;47mmatch:\e[0m $(pwd)/$1@$cnt"
			fi
			((found++))
		fi
	done
}
else
function match {
	if [[ "$1" == *"$2"* ]]
	then
        clline
		if [[ -v Optpager ]]
		then plist="$plist\n$(pwd)$file"
		else echo -e "\r\e[30;47mmatch:\e[0m $(pwd)/$1"
		fi
		((found++))
     fi
}
fi

((es=0));((ds=0));((fs=0));((found=0))

function search {
q="$1"
    for file in * $pattern
    do
	if [[ -L "$file" ]]
	then continue
        elif [[ -f "$file" ]]
        then ((fs++))
			match "$file" "$q" &
        elif [[ -d "$file" ]]
        then ((ds++))
            match "$file" "$q" &
            cd "$file" 2> /dev/null || continue
displaypath
			[[ "$Subs" -ge "$MaxSubs" ]] && {
				#echo "max subs reached, waiting"
				wait
				((Subs=0))
				#echo "done"
			}
			((Subs++))
			eval "search $q $Optf"
            cd ..
        else
            match "$file" "$q" &
        fi
        #echo -ne "\033[[0k\r"
    done
	wait
}

trap "error interrupt" SIGINT

# set title
[[ -v Optf ]] && status+=("fast mode")
echo -ne "\033]0;$q: search by vosje (${status[@]})\007" # xterm and most other


echo -e "searching for $q:"
[[ -v Optpager ]] || {
echo -ne "\n\e[30;47m"
printf "=%.0s" $(eval "echo {1..$COLUMNS}")
echo -e "\e[0m\n"
}

search $1

# echo -ne "\033[[0k\r"
wait
status+=("done")
command -v "notify-send" >/dev/null && notify-send "search by vosje" "search for $q in $(pwd): done.\nstatus: ${status[@]}\ntty: $(tty)\nresults: $results" >/dev/null 2&>1
command -v "termux-toast" >/dev/null && termux-toast "search for $q done" && termux-toast "results: $results" >/dev/null 2&>1

clline
[[ -v Optpager ]] || {
echo -e "\e[30;47m"
printf "=%.0s" $(eval "echo {1..$COLUMNS}") && echo -e "\e[0m"
}
if [[ -v Optf ]]
then echo "stats are disabled becouse of fast mode"
else echo -e "\n\e[30;47msearched\e[0m\n$ds folders,\n$fs files,\n$es unknown,\n\e[30;47mfound\e[0m\n$found results."
fi
echo -e "\e[30;47mdone\e[0m"
[[ -v Optpager ]] && {
	[[ ! -v PAGER || "$PAGER" == '' ]] || ! command -v "$PAGER" > /dev/null && {
		if command -v less > /dev/null
		then PAGER=less
		elif command -v more > /dev/null
		then PAGER=more
		elif command -v cat > /dev/null
		then PAGER=cat
		else echo -e "\e[1;31mno pager found. export the PAGER variable containing the path to your pager to use this feature.\e[0m"; echo -e "\e[30;47mhere are your results:\e[0m\n$plist"; exit 1
		fi
	}
	[[ -v PAGER ]] && echo -e "$plist" | $PAGER
}


[[ "$debug" == 1 ]] && set +x

